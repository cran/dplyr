<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>

<title>Window functions and grouped mutate/filter</title>

<script type="text/javascript">
window.onload = function() {
  var imgs = document.getElementsByTagName('img'), i, img;
  for (i = 0; i < imgs.length; i++) {
    img = imgs[i];
    // center an image if it is the only element of its parent
    if (img.parentElement.childElementCount === 1)
      img.parentElement.style.textAlign = 'center';
  }
};
</script>

<!-- Styles for R syntax highlighter -->
<style type="text/css">
   pre .operator,
   pre .paren {
     color: rgb(104, 118, 135)
   }

   pre .literal {
     color: #990073
   }

   pre .number {
     color: #099;
   }

   pre .comment {
     color: #998;
     font-style: italic
   }

   pre .keyword {
     color: #900;
     font-weight: bold
   }

   pre .identifier {
     color: rgb(0, 0, 0);
   }

   pre .string {
     color: #d14;
   }
</style>

<!-- R syntax highlighter -->
<script type="text/javascript">
var hljs=new function(){function m(p){return p.replace(/&/gm,"&amp;").replace(/</gm,"&lt;")}function f(r,q,p){return RegExp(q,"m"+(r.cI?"i":"")+(p?"g":""))}function b(r){for(var p=0;p<r.childNodes.length;p++){var q=r.childNodes[p];if(q.nodeName=="CODE"){return q}if(!(q.nodeType==3&&q.nodeValue.match(/\s+/))){break}}}function h(t,s){var p="";for(var r=0;r<t.childNodes.length;r++){if(t.childNodes[r].nodeType==3){var q=t.childNodes[r].nodeValue;if(s){q=q.replace(/\n/g,"")}p+=q}else{if(t.childNodes[r].nodeName=="BR"){p+="\n"}else{p+=h(t.childNodes[r])}}}if(/MSIE [678]/.test(navigator.userAgent)){p=p.replace(/\r/g,"\n")}return p}function a(s){var r=s.className.split(/\s+/);r=r.concat(s.parentNode.className.split(/\s+/));for(var q=0;q<r.length;q++){var p=r[q].replace(/^language-/,"");if(e[p]){return p}}}function c(q){var p=[];(function(s,t){for(var r=0;r<s.childNodes.length;r++){if(s.childNodes[r].nodeType==3){t+=s.childNodes[r].nodeValue.length}else{if(s.childNodes[r].nodeName=="BR"){t+=1}else{if(s.childNodes[r].nodeType==1){p.push({event:"start",offset:t,node:s.childNodes[r]});t=arguments.callee(s.childNodes[r],t);p.push({event:"stop",offset:t,node:s.childNodes[r]})}}}}return t})(q,0);return p}function k(y,w,x){var q=0;var z="";var s=[];function u(){if(y.length&&w.length){if(y[0].offset!=w[0].offset){return(y[0].offset<w[0].offset)?y:w}else{return w[0].event=="start"?y:w}}else{return y.length?y:w}}function t(D){var A="<"+D.nodeName.toLowerCase();for(var B=0;B<D.attributes.length;B++){var C=D.attributes[B];A+=" "+C.nodeName.toLowerCase();if(C.value!==undefined&&C.value!==false&&C.value!==null){A+='="'+m(C.value)+'"'}}return A+">"}while(y.length||w.length){var v=u().splice(0,1)[0];z+=m(x.substr(q,v.offset-q));q=v.offset;if(v.event=="start"){z+=t(v.node);s.push(v.node)}else{if(v.event=="stop"){var p,r=s.length;do{r--;p=s[r];z+=("</"+p.nodeName.toLowerCase()+">")}while(p!=v.node);s.splice(r,1);while(r<s.length){z+=t(s[r]);r++}}}}return z+m(x.substr(q))}function j(){function q(x,y,v){if(x.compiled){return}var u;var s=[];if(x.k){x.lR=f(y,x.l||hljs.IR,true);for(var w in x.k){if(!x.k.hasOwnProperty(w)){continue}if(x.k[w] instanceof Object){u=x.k[w]}else{u=x.k;w="keyword"}for(var r in u){if(!u.hasOwnProperty(r)){continue}x.k[r]=[w,u[r]];s.push(r)}}}if(!v){if(x.bWK){x.b="\\b("+s.join("|")+")\\s"}x.bR=f(y,x.b?x.b:"\\B|\\b");if(!x.e&&!x.eW){x.e="\\B|\\b"}if(x.e){x.eR=f(y,x.e)}}if(x.i){x.iR=f(y,x.i)}if(x.r===undefined){x.r=1}if(!x.c){x.c=[]}x.compiled=true;for(var t=0;t<x.c.length;t++){if(x.c[t]=="self"){x.c[t]=x}q(x.c[t],y,false)}if(x.starts){q(x.starts,y,false)}}for(var p in e){if(!e.hasOwnProperty(p)){continue}q(e[p].dM,e[p],true)}}function d(B,C){if(!j.called){j();j.called=true}function q(r,M){for(var L=0;L<M.c.length;L++){if((M.c[L].bR.exec(r)||[null])[0]==r){return M.c[L]}}}function v(L,r){if(D[L].e&&D[L].eR.test(r)){return 1}if(D[L].eW){var M=v(L-1,r);return M?M+1:0}return 0}function w(r,L){return L.i&&L.iR.test(r)}function K(N,O){var M=[];for(var L=0;L<N.c.length;L++){M.push(N.c[L].b)}var r=D.length-1;do{if(D[r].e){M.push(D[r].e)}r--}while(D[r+1].eW);if(N.i){M.push(N.i)}return f(O,M.join("|"),true)}function p(M,L){var N=D[D.length-1];if(!N.t){N.t=K(N,E)}N.t.lastIndex=L;var r=N.t.exec(M);return r?[M.substr(L,r.index-L),r[0],false]:[M.substr(L),"",true]}function z(N,r){var L=E.cI?r[0].toLowerCase():r[0];var M=N.k[L];if(M&&M instanceof Array){return M}return false}function F(L,P){L=m(L);if(!P.k){return L}var r="";var O=0;P.lR.lastIndex=0;var M=P.lR.exec(L);while(M){r+=L.substr(O,M.index-O);var N=z(P,M);if(N){x+=N[1];r+='<span class="'+N[0]+'">'+M[0]+"</span>"}else{r+=M[0]}O=P.lR.lastIndex;M=P.lR.exec(L)}return r+L.substr(O,L.length-O)}function J(L,M){if(M.sL&&e[M.sL]){var r=d(M.sL,L);x+=r.keyword_count;return r.value}else{return F(L,M)}}function I(M,r){var L=M.cN?'<span class="'+M.cN+'">':"";if(M.rB){y+=L;M.buffer=""}else{if(M.eB){y+=m(r)+L;M.buffer=""}else{y+=L;M.buffer=r}}D.push(M);A+=M.r}function G(N,M,Q){var R=D[D.length-1];if(Q){y+=J(R.buffer+N,R);return false}var P=q(M,R);if(P){y+=J(R.buffer+N,R);I(P,M);return P.rB}var L=v(D.length-1,M);if(L){var O=R.cN?"</span>":"";if(R.rE){y+=J(R.buffer+N,R)+O}else{if(R.eE){y+=J(R.buffer+N,R)+O+m(M)}else{y+=J(R.buffer+N+M,R)+O}}while(L>1){O=D[D.length-2].cN?"</span>":"";y+=O;L--;D.length--}var r=D[D.length-1];D.length--;D[D.length-1].buffer="";if(r.starts){I(r.starts,"")}return R.rE}if(w(M,R)){throw"Illegal"}}var E=e[B];var D=[E.dM];var A=0;var x=0;var y="";try{var s,u=0;E.dM.buffer="";do{s=p(C,u);var t=G(s[0],s[1],s[2]);u+=s[0].length;if(!t){u+=s[1].length}}while(!s[2]);if(D.length>1){throw"Illegal"}return{r:A,keyword_count:x,value:y}}catch(H){if(H=="Illegal"){return{r:0,keyword_count:0,value:m(C)}}else{throw H}}}function g(t){var p={keyword_count:0,r:0,value:m(t)};var r=p;for(var q in e){if(!e.hasOwnProperty(q)){continue}var s=d(q,t);s.language=q;if(s.keyword_count+s.r>r.keyword_count+r.r){r=s}if(s.keyword_count+s.r>p.keyword_count+p.r){r=p;p=s}}if(r.language){p.second_best=r}return p}function i(r,q,p){if(q){r=r.replace(/^((<[^>]+>|\t)+)/gm,function(t,w,v,u){return w.replace(/\t/g,q)})}if(p){r=r.replace(/\n/g,"<br>")}return r}function n(t,w,r){var x=h(t,r);var v=a(t);var y,s;if(v){y=d(v,x)}else{return}var q=c(t);if(q.length){s=document.createElement("pre");s.innerHTML=y.value;y.value=k(q,c(s),x)}y.value=i(y.value,w,r);var u=t.className;if(!u.match("(\\s|^)(language-)?"+v+"(\\s|$)")){u=u?(u+" "+v):v}if(/MSIE [678]/.test(navigator.userAgent)&&t.tagName=="CODE"&&t.parentNode.tagName=="PRE"){s=t.parentNode;var p=document.createElement("div");p.innerHTML="<pre><code>"+y.value+"</code></pre>";t=p.firstChild.firstChild;p.firstChild.cN=s.cN;s.parentNode.replaceChild(p.firstChild,s)}else{t.innerHTML=y.value}t.className=u;t.result={language:v,kw:y.keyword_count,re:y.r};if(y.second_best){t.second_best={language:y.second_best.language,kw:y.second_best.keyword_count,re:y.second_best.r}}}function o(){if(o.called){return}o.called=true;var r=document.getElementsByTagName("pre");for(var p=0;p<r.length;p++){var q=b(r[p]);if(q){n(q,hljs.tabReplace)}}}function l(){if(window.addEventListener){window.addEventListener("DOMContentLoaded",o,false);window.addEventListener("load",o,false)}else{if(window.attachEvent){window.attachEvent("onload",o)}else{window.onload=o}}}var e={};this.LANGUAGES=e;this.highlight=d;this.highlightAuto=g;this.fixMarkup=i;this.highlightBlock=n;this.initHighlighting=o;this.initHighlightingOnLoad=l;this.IR="[a-zA-Z][a-zA-Z0-9_]*";this.UIR="[a-zA-Z_][a-zA-Z0-9_]*";this.NR="\\b\\d+(\\.\\d+)?";this.CNR="\\b(0[xX][a-fA-F0-9]+|(\\d+(\\.\\d*)?|\\.\\d+)([eE][-+]?\\d+)?)";this.BNR="\\b(0b[01]+)";this.RSR="!|!=|!==|%|%=|&|&&|&=|\\*|\\*=|\\+|\\+=|,|\\.|-|-=|/|/=|:|;|<|<<|<<=|<=|=|==|===|>|>=|>>|>>=|>>>|>>>=|\\?|\\[|\\{|\\(|\\^|\\^=|\\||\\|=|\\|\\||~";this.ER="(?![\\s\\S])";this.BE={b:"\\\\.",r:0};this.ASM={cN:"string",b:"'",e:"'",i:"\\n",c:[this.BE],r:0};this.QSM={cN:"string",b:'"',e:'"',i:"\\n",c:[this.BE],r:0};this.CLCM={cN:"comment",b:"//",e:"$"};this.CBLCLM={cN:"comment",b:"/\\*",e:"\\*/"};this.HCM={cN:"comment",b:"#",e:"$"};this.NM={cN:"number",b:this.NR,r:0};this.CNM={cN:"number",b:this.CNR,r:0};this.BNM={cN:"number",b:this.BNR,r:0};this.inherit=function(r,s){var p={};for(var q in r){p[q]=r[q]}if(s){for(var q in s){p[q]=s[q]}}return p}}();hljs.LANGUAGES.cpp=function(){var a={keyword:{"false":1,"int":1,"float":1,"while":1,"private":1,"char":1,"catch":1,"export":1,virtual:1,operator:2,sizeof:2,dynamic_cast:2,typedef:2,const_cast:2,"const":1,struct:1,"for":1,static_cast:2,union:1,namespace:1,unsigned:1,"long":1,"throw":1,"volatile":2,"static":1,"protected":1,bool:1,template:1,mutable:1,"if":1,"public":1,friend:2,"do":1,"return":1,"goto":1,auto:1,"void":2,"enum":1,"else":1,"break":1,"new":1,extern:1,using:1,"true":1,"class":1,asm:1,"case":1,typeid:1,"short":1,reinterpret_cast:2,"default":1,"double":1,register:1,explicit:1,signed:1,typename:1,"try":1,"this":1,"switch":1,"continue":1,wchar_t:1,inline:1,"delete":1,alignof:1,char16_t:1,char32_t:1,constexpr:1,decltype:1,noexcept:1,nullptr:1,static_assert:1,thread_local:1,restrict:1,_Bool:1,complex:1},built_in:{std:1,string:1,cin:1,cout:1,cerr:1,clog:1,stringstream:1,istringstream:1,ostringstream:1,auto_ptr:1,deque:1,list:1,queue:1,stack:1,vector:1,map:1,set:1,bitset:1,multiset:1,multimap:1,unordered_set:1,unordered_map:1,unordered_multiset:1,unordered_multimap:1,array:1,shared_ptr:1}};return{dM:{k:a,i:"</",c:[hljs.CLCM,hljs.CBLCLM,hljs.QSM,{cN:"string",b:"'\\\\?.",e:"'",i:"."},{cN:"number",b:"\\b(\\d+(\\.\\d*)?|\\.\\d+)(u|U|l|L|ul|UL|f|F)"},hljs.CNM,{cN:"preprocessor",b:"#",e:"$"},{cN:"stl_container",b:"\\b(deque|list|queue|stack|vector|map|set|bitset|multiset|multimap|unordered_map|unordered_set|unordered_multiset|unordered_multimap|array)\\s*<",e:">",k:a,r:10,c:["self"]}]}}}();hljs.LANGUAGES.r={dM:{c:[hljs.HCM,{cN:"number",b:"\\b0[xX][0-9a-fA-F]+[Li]?\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\b\\d+(?:[eE][+\\-]?\\d*)?L\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\b\\d+\\.(?!\\d)(?:i\\b)?",e:hljs.IMMEDIATE_RE,r:1},{cN:"number",b:"\\b\\d+(?:\\.\\d*)?(?:[eE][+\\-]?\\d*)?i?\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\.\\d+(?:[eE][+\\-]?\\d*)?i?\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"keyword",b:"(?:tryCatch|library|setGeneric|setGroupGeneric)\\b",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\.\\.\\.",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\.\\.\\d+(?![\\w.])",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\b(?:function)",e:hljs.IMMEDIATE_RE,r:2},{cN:"keyword",b:"(?:if|in|break|next|repeat|else|for|return|switch|while|try|stop|warning|require|attach|detach|source|setMethod|setClass)\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"literal",b:"(?:NA|NA_integer_|NA_real_|NA_character_|NA_complex_)\\b",e:hljs.IMMEDIATE_RE,r:10},{cN:"literal",b:"(?:NULL|TRUE|FALSE|T|F|Inf|NaN)\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"identifier",b:"[a-zA-Z.][a-zA-Z0-9._]*\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"operator",b:"<\\-(?!\\s*\\d)",e:hljs.IMMEDIATE_RE,r:2},{cN:"operator",b:"\\->|<\\-",e:hljs.IMMEDIATE_RE,r:1},{cN:"operator",b:"%%|~",e:hljs.IMMEDIATE_RE},{cN:"operator",b:">=|<=|==|!=|\\|\\||&&|=|\\+|\\-|\\*|/|\\^|>|<|!|&|\\||\\$|:",e:hljs.IMMEDIATE_RE,r:0},{cN:"operator",b:"%",e:"%",i:"\\n",r:1},{cN:"identifier",b:"`",e:"`",r:0},{cN:"string",b:'"',e:'"',c:[hljs.BE],r:0},{cN:"string",b:"'",e:"'",c:[hljs.BE],r:0},{cN:"paren",b:"[[({\\])}]",e:hljs.IMMEDIATE_RE,r:0}]}};
hljs.initHighlightingOnLoad();
</script>



<style type="text/css">
body, td {
   font-family: sans-serif;
   background-color: white;
   font-size: 13px;
}

body {
  max-width: 800px;
  margin: auto;
  padding: 1em;
  line-height: 20px;
}

tt, code, pre {
   font-family: 'DejaVu Sans Mono', 'Droid Sans Mono', 'Lucida Console', Consolas, Monaco, monospace;
}

h1 {
   font-size:2.2em;
}

h2 {
   font-size:1.8em;
}

h3 {
   font-size:1.4em;
}

h4 {
   font-size:1.0em;
}

h5 {
   font-size:0.9em;
}

h6 {
   font-size:0.8em;
}

a:visited {
   color: rgb(50%, 0%, 50%);
}

pre, img {
  max-width: 100%;
}
pre {
  overflow-x: auto;
}
pre code {
   display: block; padding: 0.5em;
}

code {
  font-size: 92%;
  border: 1px solid #ccc;
}

code[class] {
  background-color: #F8F8F8;
}

table, td, th {
  border: none;
}

blockquote {
   color:#666666;
   margin:0;
   padding-left: 1em;
   border-left: 0.5em #EEE solid;
}

hr {
   height: 0px;
   border-bottom: none;
   border-top-width: thin;
   border-top-style: dotted;
   border-top-color: #999999;
}

@media print {
   * {
      background: transparent !important;
      color: black !important;
      filter:none !important;
      -ms-filter: none !important;
   }

   body {
      font-size:12pt;
      max-width:100%;
   }

   a, a:visited {
      text-decoration: underline;
   }

   hr {
      visibility: hidden;
      page-break-before: always;
   }

   pre, blockquote {
      padding-right: 1em;
      page-break-inside: avoid;
   }

   tr, img {
      page-break-inside: avoid;
   }

   img {
      max-width: 100% !important;
   }

   @page :left {
      margin: 15mm 20mm 15mm 10mm;
   }

   @page :right {
      margin: 15mm 10mm 15mm 20mm;
   }

   p, h2, h3 {
      orphans: 3; widows: 3;
   }

   h2, h3 {
      page-break-after: avoid;
   }
}
</style>



</head>

<body>
<!--
%\VignetteEngine{knitr}
%\VignetteIndexEntry{Window functions}
-->

<h1>Window functions and grouped mutate/filter</h1>

<p>A <strong>window function</strong> is a variation on an aggregation function. Where an aggregation function, like <code>sum()</code> and <code>mean()</code>, takes n inputs and return a single value, a window function returns n values. The output of a window function depends on all its input values, so window functions don&#39;t include functions that work element-wise, like <code>+</code> or <code>round()</code>. Window functions include variations on aggregate functions, like <code>cumsum()</code> and <code>cummean()</code>, functions for ranking and ordering, like <code>rank()</code>, and functions for taking offsets, like <code>lead()</code> and <code>lag()</code>. </p>

<p>Window functions are used in conjunction with <code>mutate</code> and <code>filter</code> to solve a wide range of problems, some of which are shown below:</p>

<pre><code class="r">library(Lahman)
</code></pre>

<pre><code>#&gt; Warning: package &#39;Lahman&#39; was built under R version 3.1.1
</code></pre>

<pre><code class="r">batting &lt;- select(tbl_df(Batting), playerID, yearID, teamID, G, AB:H) 
batting &lt;- arrange(batting, playerID, yearID, teamID)
players &lt;- group_by(batting, playerID)

# For each player, find the two years with most hits
filter(players, min_rank(desc(H)) &lt;= 2 &amp; H &gt; 0)
# Within each player, rank each year by the number of games played
mutate(players, G_rank = min_rank(G))

# For each player, find every year that was better than the previous year
filter(players, G &gt; lag(G))
# For each player, compute avg change in games played per year
mutate(players, G_change = (G - lag(G)) / (yearID - lag(yearID)))

# For each player, find all where they played more games than average
filter(players, G &gt; mean(G))
# For each, player compute a z score based on number of games played
mutate(players, G_z = (G - mean(G)) / sd(G))
</code></pre>

<p>This vignette is broken down into two sections. First you&#39;ll learn about the five families of window functions in R, and what you can use them for. If you&#39;re only working with local data sources, you can stop there. Otherwise, continue on to learn about window functions in SQL. They are relatively new, but are supported by Postgres, Amazon&#39;s Redshift and Google&#39;s bigquery. The window functions themselves are basically the same (modulo a few name conflicts), but their specification is a little different. I&#39;ll briefy review how they work, and then show how dplyr translates their R equivalents to SQL.</p>

<p>Before reading this vignette, you should be familiar with <code>mutate()</code> and <code>filter()</code>. If you want to use window functions with SQL databases, you should also be familiar with the basics of dplyr&#39;s SQL translation.</p>

<h2>Types of window functions</h2>

<p>There are five main families of window functions. Two families are unrelated to aggregation functions:</p>

<ul>
<li><p>Ranking and ordering functions: <code>row_number()</code>, <code>min_rank</code> (<code>RANK</code> in SQL),
<code>dense_rank()</code>, <code>cume_dist()</code>, <code>percent_rank()</code>, and <code>ntile()</code>. These 
functions all take a vector to order by, and return various types of ranks.</p></li>
<li><p>Offsets <code>lead()</code> and <code>lag()</code> allow you to access the previous and next
values in a vector, making it easy to compute differences and trends.</p></li>
</ul>

<p>The other three families are variations on familiar aggregate functions:</p>

<ul>
<li><p>Cumulative aggregates: <code>cumsum()</code>, <code>cummin()</code>, <code>cummax()</code> (from base R), 
and <code>cumall()</code>, <code>cumany()</code>, and <code>cummean()</code> (from dplyr).</p></li>
<li><p>Rolling aggregates operate in a fixed width window. You won&#39;t find them in 
base R or in dplyr, but there are many implementations in 
other packages, such as 
<a href="http://cran.r-project.org/web/packages/RcppRoll">RcppRoll</a>.</p></li>
<li><p>Recycled aggregates, where an aggregate is repeated to match the length
of the input. These are not needed in R because vector recycling 
automatically recycles aggregates where needed. They are important in SQL, 
because the presence of an aggregation function usually tells the database 
to return only one row per group.</p></li>
</ul>

<p>Each family is described in more detail below, focussing on the general goals and how to use them with dplyr. For more details, refer to the individual function documentation.</p>

<h3>Ranking functions</h3>

<p>The ranking functions are variations on a theme, differing in how they handle ties:</p>

<pre><code class="r">x &lt;- c(1, 1, 2, 2, 2)

row_number(x)
</code></pre>

<pre><code>#&gt; [1] 1 2 3 4 5
</code></pre>

<pre><code class="r">min_rank(x)
</code></pre>

<pre><code>#&gt; [1] 1 1 3 3 3
</code></pre>

<pre><code class="r">dense_rank(x)
</code></pre>

<pre><code>#&gt; [1] 1 1 2 2 2
</code></pre>

<p>If you&#39;re familiar with R, you may recognise that <code>row_number()</code> and <code>min_rank()</code> can be computed with the base <code>rank()</code> function and various values of the <code>ties.method</code> argument. These functions are provided to save a little typing, and to make it easier to convert between R and SQL.</p>

<p>Two other ranking functions return numbers between 0 and 1. <code>percent_rank()</code> gives the percentage of the rank; <code>cume_dist()</code> gives the proportion of values less than or equal to the current value. </p>

<pre><code class="r">cume_dist(x)
</code></pre>

<pre><code>#&gt; [1] 0.4 0.4 1.0 1.0 1.0
</code></pre>

<pre><code class="r">percent_rank(x)
</code></pre>

<pre><code>#&gt; [1] 0.0 0.0 0.5 0.5 0.5
</code></pre>

<p>These are useful if you want to select (for example) the top 10% of records within each group. For example:</p>

<pre><code class="r"># Selects best two years
filter(players, min_rank(desc(G)) &lt; 2)

# Selects best 10% of years
filter(players, cume_dist(desc(G)) &lt; 0.1)
</code></pre>

<p>Finally, <code>ntile()</code> divides the data up into <code>n</code> evenly sized buckets. It&#39;s a coarse ranking, and it can be used in with <code>mutate()</code> to divide the data into buckets for further summary. For example, we could use <code>ntile()</code> to divide the players within a team into four ranked groups, and calculate the average number of games within each group.</p>

<pre><code class="r">by_team_player &lt;- group_by(batting, teamID, playerID)
by_team &lt;- summarise(by_team_player, G = sum(G))
by_team_quartile &lt;- group_by(by_team, quartile = ntile(G, 4))
summarise(by_team_quartile, mean(G))
</code></pre>

<pre><code>#&gt; Source: local data frame [4 x 2]
#&gt; 
#&gt;   quartile mean(G)
#&gt; 1        1   5.356
#&gt; 2        2  24.912
#&gt; 3        3  77.289
#&gt; 4        4 373.693
</code></pre>

<p>All ranking functions rank from lowest to highest so that small input values get small ranks. Use <code>desc()</code> to rank from highest to lowest.</p>

<h3>Lead and lag</h3>

<p><code>lead()</code> and <code>lag()</code> produce offset versions of a input vector that is either ahead of or behind the original vector. </p>

<pre><code class="r">x &lt;- 1:5
lead(x)
</code></pre>

<pre><code>#&gt; [1]  2  3  4  5 NA
</code></pre>

<pre><code class="r">lag(x)
</code></pre>

<pre><code>#&gt; [1] NA  1  2  3  4
</code></pre>

<p>You can use them to:</p>

<ul>
<li><p>Compute differences or percent changes.</p>

<pre><code class="r"># Compute the relative change in games played
mutate(players, G_delta = G - lag(G))
</code></pre>

<p>Using <code>lag()</code> is more convenient than <code>diff()</code> because for <code>n</code> inputs 
<code>diff()</code> returns <code>n - 1</code> outputs.</p></li>
<li><p>Find out when a value changes.</p>

<pre><code class="r"># Find when a player changed teams
filter(players, teamID != lag(teamID))
</code></pre></li>
</ul>

<p><code>lead()</code> and <code>lag()</code> have an optional argument <code>order_by</code>. If set, instead of using the row order to determine which value comes before another, they will use another variable. This important if you have not already sorted the data, or you want to sort one way and lag another. </p>

<p>Here&#39;s a simple example of what happens if you don&#39;t specify <code>order_by</code> when you need it:</p>

<pre><code class="r">df &lt;- data.frame(year = 2000:2005, value = (0:5) ^ 2)
scrambled &lt;- df[sample(nrow(df)), ]

wrong &lt;- mutate(scrambled, running = cumsum(value))
arrange(wrong, year)
</code></pre>

<pre><code>#&gt;   year value running
#&gt; 1 2000     0       0
#&gt; 2 2001     1      55
#&gt; 3 2002     4       4
#&gt; 4 2003     9      13
#&gt; 5 2004    16      54
#&gt; 6 2005    25      38
</code></pre>

<pre><code class="r">right &lt;- mutate(scrambled, running = order_by(year, cumsum(value)))
arrange(right, year)
</code></pre>

<pre><code>#&gt;   year value running
#&gt; 1 2000     0       0
#&gt; 2 2001     1       1
#&gt; 3 2002     4       5
#&gt; 4 2003     9      14
#&gt; 5 2004    16      30
#&gt; 6 2005    25      55
</code></pre>

<h3>Cumulative aggregates</h3>

<p>Base R provides cumulative sum (<code>cumsum()</code>), cumulative min (<code>cummin()</code>) and cumulative max (<code>cummax()</code>). (It also provides <code>cumprod()</code> but that is rarely useful). Other common accumulating functions are <code>cumany()</code> and <code>cumall()</code>, cumulative versions of <code>||</code> and <code>&amp;&amp;</code>, and <code>cummean()</code>, a cumulative mean. These are not included in base R, but efficient versions are provided by <code>dplyr</code>. </p>

<p><code>cumany()</code> and <code>cumall()</code> are useful for selecting all rows up to, or all rows after, a condition is true for the first (or last) time. For example, we can use <code>cumany()</code> to find all records for a player after they played a year with 150 games:</p>

<pre><code class="r">filter(players, cumany(G &gt; 150))
</code></pre>

<p>Like lead and lag, you may want to control the order in which the accumulation occurs. None of the built in functions have an <code>order_by</code> argument so <code>dplyr</code> provides a helper: <code>order_by()</code>. You give it the variable you want to order by, and then the call to the window function:</p>

<pre><code class="r">x &lt;- 1:10
y &lt;- 10:1
order_by(y, cumsum(x))
</code></pre>

<pre><code>#&gt;  [1] 55 54 52 49 45 40 34 27 19 10
</code></pre>

<p>This function uses a bit of non-standard evaluation, so I wouldn&#39;t recommend using it inside another function; use the simpler but less concise <code>with_order()</code> instead.</p>

<h3>Recycled aggregates</h3>

<p>R&#39;s vector recycling make it easy to select values that are higher or lower than a summary. I call this a recycled aggregate because the value of the aggregate is recycled to be the same length as the original vector. Recycled aggregates are useful if you want to find all records greater than the mean or less than the median:</p>

<pre><code class="r">filter(players, G &gt; mean(G))
filter(players, G &lt; median(G))
</code></pre>

<p>While most SQL databases don&#39;t have an equivalent of <code>median()</code> or <code>quantile()</code>, when filtering you can achieve the same effect with <code>ntile()</code>. For example, <code>x &gt; median(x)</code> is equivalent to <code>ntile(x, 2) == 2</code>; <code>x &gt; quantile(x, 75)</code> is equivalent to <code>ntile(x, 100) &gt; 75</code> or <code>ntile(x, 4) &gt; 3</code>.</p>

<pre><code class="r">filter(players, ntile(G, 2) == 2)
</code></pre>

<p>You can also use this idea to select the records with the highest (<code>x == max(x)</code>) or lowest value (<code>x == min(x)</code>) for a field, but the ranking functions give you more control over ties, and allow you to select any number of records.</p>

<p>Recycled aggregates are also useful in conjunction with <code>mutate()</code>. For example, with the batting data, we could compute the &ldquo;career year&rdquo;, the number of years a player has played since they entered the league:</p>

<pre><code class="r">mutate(players, career_year = yearID - min(yearID) + 1)
</code></pre>

<pre><code>#&gt; Source: local data frame [97,889 x 8]
#&gt; Groups: playerID
#&gt; 
#&gt;     playerID yearID teamID  G AB R H career_year
#&gt; 1  aardsda01   2004    SFN 11  0 0 0           1
#&gt; 2  aardsda01   2006    CHN 45  2 0 0           3
#&gt; 3  aardsda01   2007    CHA 25  0 0 0           4
#&gt; 4  aardsda01   2008    BOS 47  1 0 0           5
#&gt; ..       ...    ...    ... .. .. . .         ...
</code></pre>

<p>Or, as in the introductory example, we could compute a z-score:</p>

<pre><code class="r">mutate(players, G_z = (G - mean(G)) / sd(G))
</code></pre>

<pre><code>#&gt; Source: local data frame [97,889 x 8]
#&gt; Groups: playerID
#&gt; 
#&gt;     playerID yearID teamID  G AB R H     G_z
#&gt; 1  aardsda01   2004    SFN 11  0 0 0 -1.1168
#&gt; 2  aardsda01   2006    CHN 45  2 0 0  0.3297
#&gt; 3  aardsda01   2007    CHA 25  0 0 0 -0.5212
#&gt; 4  aardsda01   2008    BOS 47  1 0 0  0.4148
#&gt; ..       ...    ...    ... .. .. . .     ...
</code></pre>

<h2>Window functions in SQL</h2>

<p>Window functions have a slightly different flavour in SQL. The syntax is a little different, and the cumulative, rolling and recycled aggregate functions are all based on the simple aggregate function. The goal in this section is not to tell you everything you need to know about window functions in SQL, but to remind you of the basics and show you how dplyr translates your R expressions in to SQL. </p>

<h3>Structure of a window function in SQL</h3>

<p>In SQL, window functions have the form <code>[expression] OVER ([partition clause] [order clause] [frame_clause])</code>:</p>

<ul>
<li><p>The <strong>expression</strong> is a combination of variable names and window functions.
Support for window functions varies from database to database, but most
support the ranking functions, <code>lead</code>, <code>lag</code>, <code>nth</code>, <code>first</code>,
<code>last</code>, <code>count</code>, <code>min</code>, <code>max</code>, <code>sum</code>, <code>avg</code> and <code>stddev</code>. dplyr 
generates this from the R expression in your <code>mutate</code> or <code>filter</code> call.</p></li>
<li><p>The <strong>partition clause</strong> specifies how the window function is broken down
over groups. It plays an analogous role to <code>GROUP BY</code> for aggregate functions,
and <code>group_by()</code> in dplyr. It is possible for different window functions to 
be partitioned into different groups, but not all databases support it, and
neither does dplyr.</p></li>
<li><p>The <strong>order clause</strong> controls the ordering (when it makes a difference).
This is important for the ranking functions since it specifies which 
variables to rank by, but it&#39;s also needed for cumulative functions and lead.
Whenever you&#39;re thinking about before and after in SQL, you must always tell 
it which variable defines the order. In dplyr you do this with <code>arrange()</code>. 
If the order clause is missing when needed, some databases fail with an
error message while others return non-deterministic results.</p></li>
<li><p>The <strong>frame clause</strong> defines which rows, or <strong>frame</strong>, that are passed 
to the window function, describing which rows (relative to the current row)
should be included. The frame clause provides two offsets which determine
the start and end of frame. There are three special values: -Inf means
to include all preceeding rows (in SQL, &ldquo;unbounded preceding&rdquo;), 0 means the
current row (&ldquo;current row&rdquo;), and Inf means all following rows (&ldquo;unbounded
following)&rdquo;. The complete set of options is comprehensive, but fairly 
confusing, and is summarised visually below.</p>

<p><img src="data:image/png;base64,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" alt="A visual summary of frame options"/></p>

<p>Of the many possible specifications, there are only three that commonly
used. They select between aggregation variants:</p>

<ul>
<li>Recycled: <code>BETWEEN UNBOUND PRECEEDING AND UNBOUND FOLLOWING</code></li>
<li>Cumulative: <code>BETWEEN UNBOUND PRECEEDING AND CURRENT ROW</code></li>
<li>Rolling: <code>BETWEEN 2 PRECEEDING AND 2 FOLLOWING</code></li>
</ul>

<p>dplyr generates the frame clause based on whether your using a recycled
aggregate or a cumulative aggregate.</p></li>
</ul>

<p>It&#39;s easiest to understand these specifications by looking at a few examples. Simple examples just need the partition and order clauses:</p>

<ul>
<li><p>Rank each year within a player by number of home runs: 
<code>RANK() OVER (PARTITION BY playerID ORDER BY desc(H))</code></p></li>
<li><p>Compute change in number of games from one year to the next:
<code>G - LAG(G) OVER (PARTITION G playerID ORDER BY yearID)</code></p></li>
</ul>

<p>Aggregate variants are more verbose because we also need to supply the frame clause:</p>

<ul>
<li><p>Running sum of G for each player: <code>SUM(G) OVER (PARTITION BY playerID ORDER BY yearID BETWEEN UNBOUND PRECEEDING AND CURRENT ROW)</code></p></li>
<li><p>Compute the career year: <code>YearID - min(YearID) OVER (PARTITION BY playerID BETWEEN UNBOUND PRECEEDING AND UNBOUND FOLLOWING) + 1</code> </p></li>
<li><p>Compute a rolling average of games player: <code>MEAN(G) OVER (PARTITION BY playerID ORDER BY yearID BETWEEN 2 PRECEEDING AND 2 FOLLOWING)</code></p></li>
</ul>

<p>You&#39;ll notice that window functions in SQL are more verbose than in R. This is because different window functions can have different partitions, and the frame specification is more general than the two aggregate variants (recycled and cumulative) provided by dplyr. dplyr makes a tradeoff: you can&#39;t access rarely used window function capabilities (unless you write raw SQL), but in return, common operations are much more succinct.</p>

<h3>Translating dplyr to SQL</h3>

<p>To see how individual window functions are translated to SQL, we can use <code>translate_sql()</code> with the argument <code>window = TRUE</code>.</p>

<pre><code class="r">if (has_lahman(&quot;postgres&quot;)) {
  players_db &lt;- group_by(tbl(lahman_postgres(), &quot;Batting&quot;), playerID)

  print(translate_sql(mean(G), tbl = players_db, window = TRUE))
  print(translate_sql(cummean(G), tbl = players_db, window = TRUE))
  print(translate_sql(rank(G), tbl = players_db, window = TRUE))
  print(translate_sql(ntile(G, 2), tbl = players_db, window = TRUE))
  print(translate_sql(lag(G), tbl = players_db, window = TRUE))
}
</code></pre>

<p>If the tbl has been arranged previously, then that ordering will be used for the order clause:</p>

<pre><code class="r">if (has_lahman(&quot;postgres&quot;)) {
  players_by_year &lt;- arrange(players_db, yearID)
  print(translate_sql(cummean(G), tbl = players_by_year, window = TRUE))
  print(translate_sql(rank(), tbl = players_by_year, window = TRUE))
  print(translate_sql(lag(G), tbl = players_by_year, window = TRUE))
}
</code></pre>

<p>There are some challenges when translating window functions between R and SQL, because dplyr tries to keep the window functions as similar as possible to both the existing R analogues and to the SQL functions. This means that there are three ways to control the order clause depending on which window function you&#39;re using:</p>

<ul>
<li><p>For ranking functions, the ordering variable is the first argument: <code>rank(x)</code>,
<code>ntile(y, 2)</code>. If omitted or <code>NULL</code>, will use the default ordering associated 
with the tbl (as set by <code>arrange()</code>).</p></li>
<li><p>Accumulating aggegates only take a single argument (the vector to aggregate).
To control ordering, use <code>order_by()</code>.</p></li>
<li><p>Aggregates implemented in dplyr (<code>lead</code>, <code>lag</code>, <code>nth_value</code>, <code>first_value</code>, 
<code>last_value</code>) have an <code>order_by</code> argument. Supply it to override the
default ordering.</p></li>
</ul>

<p>The three options are illustrated in the snippet below:</p>

<pre><code class="r">mutate(players,
  min_rank(yearID),
  order_by(yearID, cumsum(G)),
  lead(order_by = yearID, G)
)
</code></pre>

<p>Currently there is no way to order by multiple variables, except by setting the default ordering with <code>arrange()</code>. This will be added in a future release. </p>

<h3>Translating filters based on window functions</h3>

<p>There are some restrictions on window functions in SQL that make their use with <code>WHERE</code> somewhat challenging. Take this simple example, where we want to find the year each player played the most games:</p>

<pre><code class="r">filter(players, rank(G) == 1)
</code></pre>

<p>The following straightforward translation does not work because window functions are only allowed in <code>SELECT</code> and <code>ORDER_BY</code>. </p>

<pre><code>SELECT *
FROM Batting
WHERE rank() OVER (PARTITION BY &quot;playerID&quot; ORDER BY &quot;G&quot;) = 1;
</code></pre>

<p>Computing the window function in <code>SELECT</code> and referring to it in <code>WHERE</code> or <code>HAVING</code> doesn&#39;t work either, because <code>WHERE</code> and <code>HAVING</code> are computed before windowing functions. </p>

<pre><code>SELECT *, rank() OVER (PARTITION BY &quot;playerID&quot; ORDER BY &quot;G&quot;) as rank
FROM Batting
WHERE rank = 1;

SELECT *, rank() OVER (PARTITION BY &quot;playerID&quot; ORDER BY &quot;G&quot;) as rank
FROM Batting
HAVING rank = 1;
</code></pre>

<p>Instead, we must use a subquery:</p>

<pre><code>SELECT *
FROM (
  SELECT *, rank() OVER (PARTITION BY &quot;playerID&quot; ORDER BY &quot;G&quot;) as rank
  FROM Batting
) tmp
WHERE rank = 1;
</code></pre>

<p>And even that query is a slightly simplification because it will also add a rank column to the original columns. dplyr takes care of generating the full, verbose, query, so you can focus on your data analysis challenges.</p>

</body>

</html>
